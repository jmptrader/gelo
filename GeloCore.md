GeloCore is the minimial Gelo runtime, defined in the gelo package. It's so minimal that by itself it does nothing. It defines the parser, virtual machine, namespace mechanism, simple tracing capabilities, basic Gelo types, and the small set of commands that rely on internal types. These are everything required to create a language in Gelo, and if you need more there are standard extensions defined in GeloExtensions and a standard library of commands defined in GeloCommands, many of which simply expose the Gelo API or parts of the Go standard library.

The components of GeloCore in more detail:
  * **The [virtual machine](UsingTheVM.md)**. The VM does all the heavy lifting and coordination. It's the equivalent of an OS process for a Gelo program. It has a [namespace](Ns.md), an IO [Port](GeloTypes#Port.md) (analagous to stdin, stdout), and a pid. It handles parsing and running programs. A VM may spawn a child VM and when a VM halts all of its child VMs are destroyed.
  * **The [namespace](Ns.md)**. The namespace manages a VMs namespace and protects the coherency of values it holds (writes are atomic). A child VM may read from its parent's namespace (returning a deep copy of the value) but cannot write to its parent's namespace. Attempts to write to a parent namespace will create a value in the child's topmost namespace that shadows the name of the parent's namespace.
  * **The [tracer](GeloTracing.md)**. The tracer is global. It traces execution of all VMs and writes messages in TraceFormat to the trace [Port](GeloTypes#Port.md). See GeloTracing for more details.
  * **The GeloTypes**. GeloCore only defines the types needed by GeloCore. GeloExtensions and GeloCommands define more types. It is not at this time possible for Gelo code itself to define a new type. See GeloTypes and GeloConversions.
  * **The BuiltIns**. Very few commands rely on implementation details of GeloCore, the great majority can be defined using the public interfaces (see WritingAlienCommands). However, those that cannot be defined using these interfaces are written for you in BuiltIns.

GeloCore aims to be as simple and flexible as it can be while being as safe and easy to use as it can be. That it can do nothing on its own is it's greatest strength: it provides mechanism, you provide policy. It does provide structure and stricture, but no more than necessary. See GeloSafety for rationales and explanations of these inbuilt limitations.